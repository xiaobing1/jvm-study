# 内存

## 线程私有

### 程序计数器
当前线程所执行的字节码的行号指示器
每条线程都需要有一个独立的程序计数器， 线程私有内存
线程正在执行的是一个java方法， 这个计数器记录的是正在执行的虚拟机字节码指令的地址；正在执行的是本地方法， 这个计数器值为空
此内存区域是唯一一个不会有OutOfMemoryError情况

### Java虚拟机栈
java方法执行的线程内存模型
方法被执行时， Java虚拟机都会同步创建一个栈帧存储局部变量表、操作数栈、动态连接、方法出口等信心。每个方法被调用直至执行完毕， 就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。


## java堆
当java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。
-Xmx -Xms调整堆内存大小

经典分代： 新生代(Eden和两个Survivor)、老年代
## 方法区

存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据

调整永久代大小： -XX: MaxPermSize

## HotSpot虚拟机对象

### 对象创建
分配内存 -> 执行初始化
分配内存方式： (Java堆是否规整由所采用的垃圾收集器是否带有空间压缩整理能力决定)
1、指针碰撞:  内存规整， 分配过内存和空闲内存放两边， 移动分界点指针。 (Serial、ParNew等带压缩整理过程收集器)
2、空闲列表： 维护一个空闲内存的列表

多线程安全:
1、采用CAS配上重试机制保证更新操作原子性
2、TLAB: 每个线程在Java堆中预先分配一小块内存， 称为本地线程分配缓冲。 -XX： +/-UseTLAB 设定

设置对象头
执行构造函数

### 对象内存布局
对象头、实例数据、对齐填充

#### 对象头
1、存储对象自身运行时数据， 如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。(称为Mark Word)

2、类型指针(数组长度)

#### 实例数据
程序代码里面定义的各种类型的字段内容
存储顺序受到虚拟机分配策略参数(-XX: FieldsSAllocationStyle参数)和字段在Java源码中定义顺序影响。
HotSpot默认分配顺序: longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)
一般来说， 父类定义的变量会出现在子类之前
Hotspot虚拟机: +XX： CompactFields为true, 子类中较窄的变量也允许插入父类变量的空隙中， 以节省一点点空间

#### 对齐填充
不是必然存在, 仅仅起着占位符的做用。
由于Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象实例数据没有对齐， 就需要通过对齐填充补全