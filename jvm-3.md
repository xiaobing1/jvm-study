# 垃圾收集器与内存分配策略

### 引用
1、强引用

2、软引用: 系统将发生内存溢出异常前， 会把软引用对象列进回收范围之中进行二次回收(缓存)

3、下一次垃圾收集发生被回收

4、虚引用: 目的只是为了能在这个对象被收集器回收时收到一个系统通知
(为啥不采用finalize)

### 引用计数算法

### 可达性分析算法

对象是否有与GC Roots相连接的引用链

如果对象在进行可达性分析发现没有与GC Roots相连接的引用链, 那它将会被第一次标记, 随后进行筛选, 筛选条件是对象是否有必要执行finalize方法

筛选条件: 对象没有覆盖finalize方法, 或者finalize方法已经被虚拟机调用过

对象判定为有必要执行finalize方法, 那么对象将会被放置到F-Queue的队列中， 并在稍后由一条虚拟机自动建立、低调度优先级的finalizer线程去执行它们的finalize方法

执行并不承诺一定会等待它运行结束。

### 回收方法区

方法区垃圾收集的性价比通常是比较低的
新生代中， 对常规应用进行一次垃圾收集通常可以回收70%-99%的内存空间
方法区回收苛刻的判定条件， 其区域垃圾收集的回收成果往往远低于此

方法区垃圾收集主要两部分内容: 废弃的常量和不再使用的类型

判定类型是否属于"不再被使用的类"

1、该类所有的实例已经被回收, 即java堆中不存在该类及其任何派生子类的实例

2、加载该类的类加载器已经被回收， 这个条件除非是经过精心设计的可替换类加载器的场景， 如OSGI、JSP的重加载等，否则通常是很难达成的。

3、该类对应的java.lang.Class对象没有在任何地方被引用， 无法在任何地方通过反射访问该类的方法

Java虚拟机被允许对满足上述三个条件的无用类进行回收, 被允许回收不是必然回收
HotSpot虚拟机提供了-Xnoclassgc参数进行控制, 还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading(需要在FastDebug版本虚拟机支持)查看类加载和卸载信息

### 分代收集理论
分代收集理论假说: 
1、弱分代假说: 绝大多数对象都是朝生夕灭
2、强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3、跨代引用假说：跨代引用相对于同代引用来说仅占极少数

标记-复制算法、标记-清除算法、标记-整理算法等针对性的垃圾收集算法都是始于分代收集理论

部分收集: 目标不是完整收集整个Java堆的垃圾收集
新生代收集(Minor GC/Young GC)：目标只是新生代的垃圾收集
老年代收集(Major GC/Old GC):目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
混合收集(Mixed GC)：目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。

整堆收集(Full GC)：收集整个Java堆和方法区的垃圾回收

#### 标记-清除算法
算法分为"标记"和"清除"两个阶段：首先标记出所有需要回收的对象, 在标记完成后， 统一回收掉所有被标记的对象。反之亦然。
缺点: 
1、执行效率不稳定， 如果Java堆中包含大量对象， 而且大部分需要被回收，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率随对象数量增长而降低
2、内存空间的碎片化问题， 标记、清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

#### 标记-复制算法
解决标记-清除算法面对大量可回收对象时执行效率低问题
半区复制：可用内存按容量划分为大小相等两块， 每次只使用其中一块。当这一块内存用完了， 将还存活着的对象复制到另外一块上面， 清理掉已使用过的内存空间
缺点：
1、如果内存中多数对象是存活的， 将会产生大量的内存间复制的开销。
2、可用内存缩小为了原来的一半， 空间浪费太多

对于多数对象都是可回收的情况， 算法需要复制的就是占少数存活对象， 半区复制及内存回收， 分配内存不用考虑空间碎片的情况。

IBM研究-----新生代中的对象有98%熬不过第一轮收集
因此不需要按照1:1比例来划分新生代的内存空间

新生代内存划分采用了Appel回收策略: 既分为Eden和两块Survivor, 优化版标记-复制算法半区复制分代策略

HotSpot虚拟机默认Eden和Survivor大小比例为8:1

#### 根节点枚举
固定可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中
所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的

目前主流Java虚拟机使用的都是准确式垃圾收集
HotSpot解决方案里, 使用一组称为OopMap的数据结构直接得到哪些地方存放着对象引用。
类加载动作完成时, HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来, 在即时编译过程中， 也会在特定的位置记录下栈里和寄存器里哪些位置是引用。

#### 安全点
在OopMap的协助下, HotSpot可以快速准确地完成GC Roots枚举
现实的问题点:
可能导致引用关系变化, 或者说导致OopMap内容变化的指令非常多, 如果为 每一条指令都生成对应的OopMap, 那将会需要大量的额外存储空间， 这样垃圾收集伴随着空间成本就会变得无法忍受的高昂。

HotSpot只是在"特定的位置"记录这些信息, 这些位置被称为安全点。

用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集， 强制要求必须执行到达安全点才能够暂停。

对于安全点， 需要考虑的问题是, 如何在垃圾收集发生时让所有线程(不包括执行JNI调用的线程)都跑到最近的安全点, 停顿下来。
方式: 抢先式中断和主动式中断

#### 安全区域
用户线程处于Sleep或者Blocked, 无法响应虚拟机中断请求, 不能走到安全点中断挂起自己, 虚拟机不可能等待线程重新被激活分配处理器时间。因此引入安全区域

安全区域指确保某一段代码片段中， 引用关系不会发生变化, 在此区域任意地方开始垃圾收集都是安全的

#### 记忆集与卡表
为解决对象跨代引用带来的问题， 垃圾收集器在新生代中建立了名为记忆集的数据结构, 避免把整个老年代加进GC Roots扫描范围。
典型的如G1、ZGC和Shenandoah收集器, 都会面临相同的问题

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

卡表是最常用的一种记忆集实现方式

字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块, 这个内存块被成为卡页

一般来说， 卡页都是以2的N次幂的字节数, HotSpot使用的卡页是2的9次幂, 即512字节

数组CARD_TABLE每一个元素对应了地址范围为512字节的卡页内存块
卡页的内存包含多个对象， 卡页内有对象字段存在跨代指针， 对应卡表数组元素标识为1, 称为这个元素变脏, 筛选出卡表变脏的元素, 就能轻易得出哪些卡页内存块包含跨代指针, 把它们加入GC Roots一并扫描

#### 写屏障
HotSpot虚拟机通过写屏障技术维护卡表状态
写屏障可以看作在虚拟机层面对"引用类型字段赋值"这个动作的AOP切面, 在引用对象赋值时产生一个环形通知, 供程序执行额外的动作， 也就是说赋值的前后都在写屏障的覆盖范畴内。

HotSpot虚拟机许多收集器都有使用到写屏障, 直到G1收集器出现之前， 其他收集器都只用到了写后屏障。

-XX:+UseCondCardMark, 用来决定是否开启卡表更新的条件判断。
开启会增加一次额外判断的开销, 但能够避免伪共享问题, 两者各有性能损耗, 是否打开要根据应用实际运行情况来进行测试权衡。

#### 并发的可达性分析
"标记"阶段是所有追踪式垃圾收集算法的共同特征, 如果这个阶段会随着堆变大而等比例增加停顿时间, 其影响就会波及几乎所有的垃圾收集器, 如果能够消减这部分停顿时间的话， 那收益也将会是系统性的。

为什么必须在一个能保障一致性的快照上才能进行对象图的遍历?

三色标记作为工具辅助推导

白色: 表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始阶段，所有的对象都是白色的， 若在分析结束阶段，仍然是白色的对象， 即代表不可达

黑色：表示对象已经被垃圾收集器访问过, 且这个对象的所有引用都已经被扫描过。黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向黑色对象无须重新扫描一遍。黑色对象不可能直接(不通过灰色对象)指向某个白色对象?。

灰色：表示对象已经被垃圾收集器访问过, 但这个对象上至少存在一个引用还没有被扫描过。

"对象消失"问题: 即对象被错误回收, 当且仅当以下两个条件同时满足时, 才会产生
1、赋值器插入了一条或多条从黑色对象到白色对象的新引用。
2、赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。
(疑问: 已经标记的黑色对象引用一个新的白色对象, 不需要满足第二条件, 可造成"对象消失问题"?)

要解决并发扫描时对象消失问题， 只需破坏这两个条件的任意一个即可。
由此产生了两种解决方案：增量更新和原始快照

增量更新： 增量更新破坏的是第一个条件， 当黑色对象插入新的指向白色对象的引用关系时，将这个新插入的引用记录下来， 在并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根, 重新扫描一次。这可以简化理解为, 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。

原始快照：原始快照要破坏的是第二个条件, 当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次， 这也可以简化理解为， 无论引用关系删除与否， 都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。
(即保留标记删除前的引用，会存在对象没有回收问题， 等待下一次GC回收)

对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。
在HotSpot虚拟机中， 增量更新和原始快照这两种解决方案都有应用。
CMS是基于增量更新来做并发标记， G1、Shenandoah则是用原始快照来实现。

内存回收如何进行是由虚拟机所采用的哪一款垃圾收集器所决定的。

### 经典垃圾收集器

新生代: Serial、ParNew、Parallel Scavenge、G1
老年代: CMS、Serial Old(MSC)、Parallel Old、G1

虽然垃圾收集器的技术在不断进步， 但直到现在还没有最好的收集器出现， 更加不存在"万能"的收集器, 所以我们选择的只是对具体应用最合适的收集器

#### Serial收集器
垃圾收集时, 会暂停用户线程

HotSpot虚拟机运行在客户端模式下默认新生代收集器
优点:
1、简单高效, 额外内存消耗最小
对于单核处理器或处理器核心数较少的环境来说, Serial收集器由于没有线程交互开销, 专心做垃圾收集自然可以获得最高的单线程收集效率。

在用户桌面的应用场景以及近年来流行的部分微服务应用中， 分配给虚拟机管理的内存一般来说并不会特别大, 收集几十兆甚至一两百兆的新生代, 垃圾收集的停顿时间完全可以控制在十几、几十毫秒， 最多一百多毫秒以内， 只要不是频繁收集， 这点停顿时间对许多用户来说是完全可以接受的。
所以, Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。

#### ParNew收集器
ParNew收集器实质上是Serial收集器的多线程并行版本
除了使用多条线程进行垃圾收集之外， 其余的行为包括Serial收集器可用的所有控制参数(例如: -XX:SurvivorRatio、-XX:PertenureSizeThreshold、-XX:HandlePromotionFailure等)、收集算法、Stop the world、对象分配规则、回收策略等都与Serial收集器完全一致, 在实现上这两种收集器也共用了相当多的代码。

除了Serial收集器外, 目前只有它能与CMS收集器配合工作

ParNew收集器是激活CMS后(使用-XX:+UseConcMarkSweepGC选项)的默认新生代收集器, 也可以使用-XX:+/-UseParNewGC选项来强制指定或禁用它

Jdk9开始, CMS+ParNew收集器组合不再是官方推荐的服务端模式下的收集器解决方案, 取消了-XX:+UseParNewGC参数

-XX:ParallelGCThreads参数限制垃圾收集的线程数

#### Parallel Scavenge收集器
Parallel Scavenge收集器也是一款新生代收集器, 基于标记-复制算法实现的收集器, 也是能够并行收集的多线程收集器

Parallel Scavenge收集器的特点是它的关注点是吞吐量
Parallel Scavenge收集器的目标是达到一个可控制的吞吐量

吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)

停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序, 良好的响应速度能提升用户体验;
高吞吐量则可以最高效率地利用处理器资源, 尽快完成程序的运算任务, 主要适合在后台运算而不需要太多交互的分析任务。

精确控制吞吐量参数:
-XX:MaxGCPauseMillis:控制最大垃圾收集停顿时间
收集器将尽力保证内存回收花费时间不超过用户设定值。
垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的:
系统把新生代调得小一些, 收集300MB新生代肯定比收集500MB快, 但也直接导致垃圾收集发生得更频繁, 原来10秒收集一次、每次停顿100毫秒, 现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降, 但吞吐量也降下来了。

-XX:GCTimeRatio:直接设置吞吐量大小
参数的值应当是一个大于0小于100的整数, 也就是垃圾收集时间占总时间的比率, 相当于吞吐量的倒数, 默认值为99， 即最大1%的垃圾收集时间(1/(1+99))

Parallel Scavenge收集器经常被称为"吞吐量优先收集器"

-XX:+UseAdaptiveSizePolicy
开关参数, 这个参数被激活后, 不需要人工指定新生代大小(-Xmn)、Eden与Survivor区比例(-XX:SurvivorRatio)、晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数, 虚拟机会根据当前系统的运行情况收集性能监控信息, 动态调整这些参数以及提供最合适的停顿时间或者最大的吞吐量。
这种调节方式被称为垃圾收集的自适应调节策略。

#### Serial Old收集器
Serial Old是Serial收集器的老年代版本, 同样是一个单线程收集器, 使用标记-整理算法。
这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。
服务端模式用途
1、Jdk5以及之前版本中与Parallel Scavenge收集器搭配使用(PS MarkSweep)
2、作为CMS收集器发生失败时的后备预案, 在并发收集发生Concurrent Mode Failure时使用。

#### 