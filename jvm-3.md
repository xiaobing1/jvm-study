# 垃圾收集器与内存分配策略

### 引用
1、强引用

2、软引用: 系统将发生内存溢出异常前， 会把软引用对象列进回收范围之中进行二次回收(缓存)

3、下一次垃圾收集发生被回收

4、虚引用: 目的只是为了能在这个对象被收集器回收时收到一个系统通知
(为啥不采用finalize)

### 引用计数算法

### 可达性分析算法

对象是否有与GC Roots相连接的引用链

如果对象在进行可达性分析发现没有与GC Roots相连接的引用链, 那它将会被第一次标记, 随后进行筛选, 筛选条件是对象是否有必要执行finalize方法

筛选条件: 对象没有覆盖finalize方法, 或者finalize方法已经被虚拟机调用过

对象判定为有必要执行finalize方法, 那么对象将会被放置到F-Queue的队列中， 并在稍后由一条虚拟机自动建立、低调度优先级的finalizer线程去执行它们的finalize方法

执行并不承诺一定会等待它运行结束。

### 回收方法区

方法区垃圾收集的性价比通常是比较低的
新生代中， 对常规应用进行一次垃圾收集通常可以回收70%-99%的内存空间
方法区回收苛刻的判定条件， 其区域垃圾收集的回收成果往往远低于此

方法区垃圾收集主要两部分内容: 废弃的常量和不再使用的类型

判定类型是否属于"不再被使用的类"

1、该类所有的实例已经被回收, 即java堆中不存在该类及其任何派生子类的实例

2、加载该类的类加载器已经被回收， 这个条件除非是经过精心设计的可替换类加载器的场景， 如OSGI、JSP的重加载等，否则通常是很难达成的。

3、该类对应的java.lang.Class对象没有在任何地方被引用， 无法在任何地方通过反射访问该类的方法

Java虚拟机被允许对满足上述三个条件的无用类进行回收, 被允许回收不是必然回收
HotSpot虚拟机提供了-Xnoclassgc参数进行控制, 还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading(需要在FastDebug版本虚拟机支持)查看类加载和卸载信息

### 分代收集理论
分代收集理论假说: 
1、弱分代假说: 绝大多数对象都是朝生夕灭
2、强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3、跨代引用假说：跨代引用相对于同代引用来说仅占极少数

标记-复制算法、标记-清除算法、标记-整理算法等针对性的垃圾收集算法都是始于分代收集理论

部分收集: 目标不是完整收集整个Java堆的垃圾收集
新生代收集(Minor GC/Young GC)：目标只是新生代的垃圾收集
老年代收集(Major GC/Old GC):目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
混合收集(Mixed GC)：目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。

整堆收集(Full GC)：收集整个Java堆和方法区的垃圾回收

#### 标记-清除算法
算法分为"标记"和"清除"两个阶段：首先标记出所有需要回收的对象, 在标记完成后， 统一回收掉所有被标记的对象。反之亦然。
缺点: 
1、执行效率不稳定， 如果Java堆中包含大量对象， 而且大部分需要被回收，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率随对象数量增长而降低
2、内存空间的碎片化问题， 标记、清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

#### 标记-复制算法
解决标记-清除算法面对大量可回收对象时执行效率低问题
半区复制：可用内存按容量划分为大小相等两块， 每次只使用其中一块。当这一块内存用完了， 将还存活着的对象复制到另外一块上面， 清理掉已使用过的内存空间
缺点：
1、如果内存中多数对象是存活的， 将会产生大量的内存间复制的开销。
2、可用内存缩小为了原来的一半， 空间浪费太多

对于多数对象都是可回收的情况， 算法需要复制的就是占少数存活对象， 半区复制及内存回收， 分配内存不用考虑空间碎片的情况。

IBM研究-----新生代中的对象有98%熬不过第一轮收集
因此不需要按照1:1比例来划分新生代的内存空间

新生代内存划分采用了Appel回收策略: 既分为Eden和两块Survivor, 优化版标记-复制算法半区复制分代策略

HotSpot虚拟机默认Eden和Survivor大小比例为8:1

#### 根节点枚举
固定可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中
所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的

目前主流Java虚拟机使用的都是准确式垃圾收集
HotSpot解决方案里, 使用一组称为OopMap的数据结构直接得到哪些地方存放着对象引用。
类加载动作完成时, HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来, 在即时编译过程中， 也会在特定的位置记录下栈里和寄存器里哪些位置是引用。

#### 安全点
在OopMap的协助下, HotSpot可以快速准确地完成GC Roots枚举
现实的问题点:
可能导致引用关系变化, 或者说导致OopMap内容变化的指令非常多, 如果为 每一条指令都生成对应的OopMap, 那将会需要大量的额外存储空间， 这样垃圾收集伴随着空间成本就会变得无法忍受的高昂。

HotSpot只是在"特定的位置"记录这些信息, 这些位置被称为安全点。

用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集， 强制要求必须执行到达安全点才能够暂停。

对于安全点， 需要考虑的问题是, 如何在垃圾收集发生时让所有线程(不包括执行JNI调用的线程)都跑到最近的安全点, 停顿下来。
方式: 抢先式中断和主动式中断

#### 安全区域
用户线程处于Sleep或者Blocked, 无法响应虚拟机中断请求, 不能走到安全点中断挂起自己, 虚拟机不可能等待线程重新被激活分配处理器时间。因此引入安全区域

安全区域指确保某一段代码片段中， 引用关系不会发生变化, 在此区域任意地方开始垃圾收集都是安全的

#### 记忆集与卡表
为解决对象跨代引用带来的问题， 垃圾收集器在新生代中建立了名为记忆集的数据结构, 避免把整个老年代加进GC Roots扫描范围。
典型的如G1、ZGC和Shenandoah收集器, 都会面临相同的问题

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

卡表是最常用的一种记忆集实现方式

字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块, 这个内存块被成为卡页

一般来说， 卡页都是以2的N次幂的字节数, HotSpot使用的卡页是2的9次幂, 即512字节

数组CARD_TABLE每一个元素对应了地址范围为512字节的卡页内存块
卡页的内存包含多个对象， 卡页内有对象字段存在跨代指针， 对应卡表数组元素标识为1, 称为这个元素变脏, 筛选出卡表变脏的元素, 就能轻易得出哪些卡页内存块包含跨代指针, 把它们加入GC Roots一并扫描

#### 写屏障
HotSpot虚拟机通过写屏障技术维护卡表状态
写屏障可以看作在虚拟机层面对"引用类型字段赋值"这个动作的AOP切面, 在引用对象赋值时产生一个环形通知, 供程序执行额外的动作， 也就是说赋值的前后都在写屏障的覆盖范畴内。

HotSpot虚拟机许多收集器都有使用到写屏障, 直到G1收集器出现之前， 其他收集器都只用到了写后屏障。

-XX:+UseCondCardMark, 用来决定是否开启卡表更新的条件判断。
开启会增加一次额外判断的开销, 但能够避免伪共享问题, 两者各有性能损耗, 是否打开要根据应用实际运行情况来进行测试权衡。

#### 并发的可达性分析
"标记"阶段是所有追踪式垃圾收集算法的共同特征, 如果这个阶段会随着堆变大而等比例增加停顿时间, 其影响就会波及几乎所有的垃圾收集器, 如果能够消减这部分停顿时间的话， 那收益也将会是系统性的。

为什么必须在一个能保障一致性的快照上才能进行对象图的遍历?

三色标记作为工具辅助推导

白色: 表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始阶段，所有的对象都是白色的， 若在分析结束阶段，仍然是白色的对象， 即代表不可达

黑色：表示对象已经被垃圾收集器访问过, 且这个对象的所有引用都已经被扫描过。黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向黑色对象无须重新扫描一遍。黑色对象不可能直接(不通过灰色对象)指向某个白色对象?。

灰色：表示对象已经被垃圾收集器访问过, 但这个对象上至少存在一个引用还没有被扫描过。

"对象消失"问题: 即对象被错误回收, 当且仅当以下两个条件同时满足时, 才会产生
1、赋值器插入了一条或多条从黑色对象到白色对象的新引用。
2、赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。
(疑问: 已经标记的黑色对象引用一个新的白色对象, 不需要满足第二条件, 可造成"对象消失问题"?)

要解决并发扫描时对象消失问题， 只需破坏这两个条件的任意一个即可。
由此产生了两种解决方案：增量更新和原始快照

增量更新： 增量更新破坏的是第一个条件， 当黑色对象插入新的指向白色对象的引用关系时，将这个新插入的引用记录下来， 在并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根, 重新扫描一次。这可以简化理解为, 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。

原始快照：原始快照要破坏的是第二个条件, 当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次， 这也可以简化理解为， 无论引用关系删除与否， 都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。
(即保留标记删除前的引用，会存在对象没有回收问题， 等待下一次GC回收)

对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。
在HotSpot虚拟机中， 增量更新和原始快照这两种解决方案都有应用。
CMS是基于增量更新来做并发标记， G1、Shenandoah则是用原始快照来实现。

内存回收如何进行是由虚拟机所采用的哪一款垃圾收集器所决定的。

### 经典垃圾收集器

新生代: Serial、ParNew、Parallel Scavenge、G1
老年代: CMS、Serial Old(MSC)、Parallel Old、G1

虽然垃圾收集器的技术在不断进步， 但直到现在还没有最好的收集器出现， 更加不存在"万能"的收集器, 所以我们选择的只是对具体应用最合适的收集器

#### Serial收集器
垃圾收集时, 会暂停用户线程

HotSpot虚拟机运行在客户端模式下默认新生代收集器
优点:
1、简单高效, 额外内存消耗最小
对于单核处理器或处理器核心数较少的环境来说, Serial收集器由于没有线程交互开销, 专心做垃圾收集自然可以获得最高的单线程收集效率。

在用户桌面的应用场景以及近年来流行的部分微服务应用中， 分配给虚拟机管理的内存一般来说并不会特别大, 收集几十兆甚至一两百兆的新生代, 垃圾收集的停顿时间完全可以控制在十几、几十毫秒， 最多一百多毫秒以内， 只要不是频繁收集， 这点停顿时间对许多用户来说是完全可以接受的。
所以, Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。

#### ParNew收集器
ParNew收集器实质上是Serial收集器的多线程并行版本
除了使用多条线程进行垃圾收集之外， 其余的行为包括Serial收集器可用的所有控制参数(例如: -XX:SurvivorRatio、-XX:PertenureSizeThreshold、-XX:HandlePromotionFailure等)、收集算法、Stop the world、对象分配规则、回收策略等都与Serial收集器完全一致, 在实现上这两种收集器也共用了相当多的代码。

除了Serial收集器外, 目前只有它能与CMS收集器配合工作

ParNew收集器是激活CMS后(使用-XX:+UseConcMarkSweepGC选项)的默认新生代收集器, 也可以使用-XX:+/-UseParNewGC选项来强制指定或禁用它

Jdk9开始, CMS+ParNew收集器组合不再是官方推荐的服务端模式下的收集器解决方案, 取消了-XX:+UseParNewGC参数

-XX:ParallelGCThreads参数限制垃圾收集的线程数

#### Parallel Scavenge收集器
Parallel Scavenge收集器也是一款新生代收集器, 基于标记-复制算法实现的收集器, 也是能够并行收集的多线程收集器

Parallel Scavenge收集器的特点是它的关注点是吞吐量
Parallel Scavenge收集器的目标是达到一个可控制的吞吐量

吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)

停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序, 良好的响应速度能提升用户体验;
高吞吐量则可以最高效率地利用处理器资源, 尽快完成程序的运算任务, 主要适合在后台运算而不需要太多交互的分析任务。

精确控制吞吐量参数:
-XX:MaxGCPauseMillis:控制最大垃圾收集停顿时间
收集器将尽力保证内存回收花费时间不超过用户设定值。
垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的:
系统把新生代调得小一些, 收集300MB新生代肯定比收集500MB快, 但也直接导致垃圾收集发生得更频繁, 原来10秒收集一次、每次停顿100毫秒, 现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降, 但吞吐量也降下来了。

-XX:GCTimeRatio:直接设置吞吐量大小
参数的值应当是一个大于0小于100的整数, 也就是垃圾收集时间占总时间的比率, 相当于吞吐量的倒数, 默认值为99， 即最大1%的垃圾收集时间(1/(1+99))

Parallel Scavenge收集器经常被称为"吞吐量优先收集器"

-XX:+UseAdaptiveSizePolicy
开关参数, 这个参数被激活后, 不需要人工指定新生代大小(-Xmn)、Eden与Survivor区比例(-XX:SurvivorRatio)、晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数, 虚拟机会根据当前系统的运行情况收集性能监控信息, 动态调整这些参数以及提供最合适的停顿时间或者最大的吞吐量。
这种调节方式被称为垃圾收集的自适应调节策略。

#### Serial Old收集器
Serial Old是Serial收集器的老年代版本, 同样是一个单线程收集器, 使用标记-整理算法。
这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。
服务端模式用途
1、Jdk5以及之前版本中与Parallel Scavenge收集器搭配使用(PS MarkSweep)
2、作为CMS收集器发生失败时的后备预案, 在并发收集发生Concurrent Mode Failure时使用。

#### Parallel Old收集器
Parallel Old是Parallel Scavenge收集器的老年代版本, 支持多线程并发收集, 基于标记-整理算法实现。
JDK 6开始提供。
Parallel Scavenge收集可以和Parallel Old收集组合使用。(原本Parallel Scavenge只能跟Serial Old组合)
Parallel Old收集器出现后, "吞吐量优先"收集器终于有了比较名副其实的搭配组合, 注重吞吐量或者处理器资源较为稀缺的场合, 都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

#### CMS收集器(Concurrent Mark Sweep)
CMS收集器是一种以获取最短回收停顿时间为目标的收集器。
目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上, 这类应用通常都会较为关注服务的响应速度, 希望系统停顿时间尽可能短,, 以给用户带来良好的交互体验。

Mark Sweep(标记-清除)
CMS收集器基于标记-清除算法实现。
运作过程:
1、初始标记
2、并发标记
3、重新标记
4、并发清除

初始标记、重新标记这两个步骤仍然需要"Stop The World"

整个过程中耗时最长的并发标记和并发清除中, 垃圾收集线程可以和用户线程一起工作。

CMS是一款优秀的收集器, 并发收集、低停顿, 但还远达不到完美的程度。

明显缺点：
1、CMS收集器对处理器资源非常敏感, 会占用一部分线程而导致应用程序变慢， 降低吞吐量。
CMS默认启动的回收线程数是(处理器核心数量 + 3)/4。
2、CMS收集器无法处理"浮动垃圾", 有可能出现"Concurrent Mode Failure"失败进而导致另一次完全"Stop The World"的Full GC产生。
在CMS的并发标记和并发清理阶段, 用户线程还是继续运行, 程序在运行自然还会伴随着有新的垃圾对象不断产生, 这一部分垃圾对象是出现在标记过程结束以后, CMS无法在当次收集中处理掉它们, 只好留待下一次垃圾收集再清理掉。这一部分垃圾称为"浮动垃圾"。

CMS收集器必须预留空间供并发收集时的程序运作使用。
Jdk 5默认配置, 老年代使用了68%就会被激活
Jdk 6 CMS启动阈值默认提升至92%
CMS运行期间预留内存无法满足程序分配新对象的需要, 就会出现"并发失败"(Concurrent Mode Failure), 这时虚拟机不得不启动备案: 冻结用户线程, 临时启用Serial Old收集器重新进行老年代垃圾收集。
-XX:CMSInitiatingOccupancyFraction设置CMS启动阈值百分比
(注: 不能设置得太高, 很容易死导致并发失败产生, 性能反而降低)

3、CMS是一款基于"标记-清除"算法实现的收集器, 收集结束会产生大量空间碎片。
空间碎片过多, 将会给大对象分配带来麻烦, 往往老年代剩余很多空间, 却无法找到足够大的连续空间来分配对象, 不得不提前触发一次Full GC。
解决: -XX:+UseCMSCompactAtFullCollection开关参数(默认开启, Jdk 9开始废弃), 用于在CMS收集器不得不进行Full GC时开启内存碎片的合并和整理过程。

空间碎片解决了， 但停顿时间变长了, 因此提供以下参数
-XX:CMSFullGCsBeforeCompaction(Jdk 9开始废弃)
作用: 要求CMS收集器在执行过若干次不整理空间的Full GC之后, 下一次进入Full GC前会先进行碎片整理(默认值为0, 表示每次进入Full GC时都进行碎片整理)

#### Garbage First收集器(G1)
G1收集器是垃圾收集器技术发展史上的里程碑式的成果, 开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。
一款面向服务端应用的垃圾收集器。(Hotspot期望未来可以替换JDK5发布的CMS收集器)
Jdk9发布宣告 G1取代Parallel Scavenge加Parallel Old组合, 成为服务端模式下的默认垃圾收集器, 不推荐使用CMS收集器.

停顿时间模型: 能够支持指定在一个长度为M毫秒的时间片段内， 消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。这几乎已经是实时Java的中软实时垃圾收集器特征。

G1可以面向堆内存任何部分组成回收集进行回收， 衡量标准不再是它属于哪个分代， 而是哪块内存中存放的垃圾数量最多， 回收效益最大， 这就是G1收集器的Mixed GC模式。

G1仍是遵循分代收集理论设计， G1把连续的Java堆划分为多个大小相等的独立区域(Region), 每一个Region都可以根据需要, 扮演新生代的Eden空间、Survivor空间, 或者老年代空间。收集器能够对 扮演不通角色的Region采用不同的策略去处理。

Region中还有一类特殊的Humongous区域, 专门存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX:G1HeapRegionSize设定, 取值范围为1MB-32MB，且应为2的N次幂。
对于超过整个Region容量的超级大对象, 将会被存放在N个连续的Humongous Region之中, G1的大多数行为都把Humongous Region作为老年代的一部分进行看待。
G1之所能建立可预测的停顿时间模型, 是因为它将Region作为单次回收的最小单元, 即每次收集到的内存空间都是Region大小的整数倍, 这样可以有计划地避免在整个堆中进行全区域的垃圾收集。
G1跟踪各个Region里面的垃圾堆积的“价值”大小， 价值即回收所获得空间大小以及回收所需时间的经验值， 然后在后台维护一个优先级列表， 每次根据用户设定允许的收集停顿时间(-XX:MaxGCPauseMillis指定, 默认值为200ms), 优先处理回收价值收益最大的那些Region, 这也是Garbage First名字由来。
具有优先级的区域回收方式, 保证了G1收集器在有限的时间内获取尽可能高的收集效率。

G1解决跨Region引用 
使用记忆集避免全堆作为GC Roots扫描, G1收集器记忆集应用要复杂很多, 每个Region都维护自己的记忆集, 会记录下别的Region指向自己的指针, 并标记 这些指针分别在哪些卡页的范围之内。G1记忆集存储结构本质是一种哈希表, Key是别的Region的起始地址,  Value是一个集合, 存储元素是卡表的索引号， 双向的卡表结构。
同时由于Region数量比传统收集器的分代数量还要多得多，因此G1收集器要比其他 的传统垃圾收集器有着更高内存占用负担。 G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。

并发标记阶段保证收集线程与用户线程互不干扰运行
G1采用原始快照算法来实的。垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存内存分配上, G1为每一个Region设计了两个名为TAMS的指针， 把Region的一部分空间划分出来用于并发回收过程中的新对象分配,  并发回收时新分配对象地址必须在这两个指针位置以上。G1默认在这个地址上对象是被隐式标记的， 默认存活的。如果内存回收的速度赶不上内存分配的速度， G1收集器会被迫冻结用户线程执行， 导致Full GC产生长时间"Stop The World"。

建立可靠的停顿预测模型
G1收集器的停顿预测 模型是以衰减均值为理论基础实现的,在垃圾收集过程中， G1会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本, 并分析得出平均值、标准偏差、置信度等统计信息。衰减平均值会比普通的平均值更容易受到新数据的影响, 衰减平均值更准确地代表最近的平均状态。

G1收集器过程
初始标记(停顿线程)
并发标记
最终标记(停顿线程)
筛选回收(停顿线程)

G1除了并发标记外， 其余阶段要完全暂停用户线程, 并非纯粹追求低延迟, 官方设定目标是在延迟可控的情况下，获得尽可能高的吞吐量。
停顿期望值不应调得非常低, 调得非常低很可能出现由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存的一小部分， 收集器收集的速度跟不上分配器分配的速度， 导致垃圾慢慢堆积，最终引发Full GC反而降低性能。

对比CMS
优点: 可以指定最大停顿时间、分Region内存布局、整体看基于标记-整理算法， 局部看基于标记-复制算法， 不会产生内存空间碎片, 有利于 程序长时间运行。
缺点： 用户程序运行过程中， G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高。
G1对写后屏障的复杂操作比CMS消耗更多的运算资源， CMS的写屏障是同步操作， G1把写屏障放在类似消息队列结构中异步处理。
小内存CMS的表现大概率优于G1， 大内存应用G1大多能发挥其优势, 这个优劣势的Java堆容量平衡点通常在6GB-8GB之间。

#### Shenandoah收集器
RedHat把Shenandoah贡献给OpenJDK, 推动它成为OpenJDK 12的正式特性之一。
这个项目的目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器， Shenandoah不仅要进行并发垃圾标记， 还要并发地进行对象清理后的整理动作。

与G1相似的内存布局
Shenandoah相比G1的改进
支持并发的整理算法
默认不使用分代收集
摒弃G1中耗费大量内存和计算资源维护的记忆集, 改用连接矩阵的全局数据结构来记录跨Region的引用关系降低了处理跨代指针的记忆集维护消耗, 也降低了伪共享问题的发生概率。
连接矩阵可以简单理解为一张二维表格

Shenandoah工作过程
初始标记
并发标记
最终标记
并发清理
并发回收
初始引用更新
并发引用更新
最终引用更新
并发清理

使用了转发指针来实现对象移动与用户程序并发的一种解决方案。
缺点: 每次对象访问会带来一次额外的转向开销, 尽管这个转向开销已经被优化到只有一行汇编指令的程度
Shenandoah使用了读屏障, 代码对象读取的出现频率比对象写入频率高出很多, 数量庞大的读屏障带来的性能开销是Shenandoah诟病的关键点之一。

#### ZGC收集器
ZGC和Shenandoah目标高度相似, 希望尽可能在对吞吐量影响不大的前提, 实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。
ZGC收集器是一款基于Region内存布局, 不设分代的, 使用了读屏障、染色指针和内存多重映射等技术来实现可并发标记-整理算法的， 以低延迟为首要目标的一款垃圾收集器。

ZGC也采用基于Region的堆内存布局,  ZGC的Region具有动态性-----动态创建和销毁, 以及动态的区域容量大小。
x64硬件平台下,ZGC的Region容量
小型Region: 容量固定为2MB, 用于放置小于256KB的小对象。
中型Region: 容量固定为32MB, 用于放置大于等于256KB但小于4MB的对象
大型Region: 容量不固定, 可以动态变化, 但必须为2MB的整数倍, 用来存放4MB及以上对象。每个大型Region只会存放一个大对象。大型Region不会被重分配。

ZGC收集器标记性的设计是它采用的染色指针技术。
比如三色标记, HotSpot虚拟机的几种收集器都有不同实现方案, 有的把标记直接记录在对象头上(如Serial收集器),有的把标记记录在与对象相互独立的数据结构上(如G1、Shenandoah使用一种相当于堆内存的1/64大小的, 称为BitMap的结构来记录标记信息),ZGC的染色指针是最直接、最纯粹的, 直接把标记信息记在引用对象的指针上。此时可达性分析就是遍历引用图来标记引用。

染色指针将其高4位用来存储信息
Finalizable: 是否只能通过Finalize方法才能被访问到
Remapped: 是否进入了重分配集(即被移动过)
Marked1: 三色标记位
Marked0: 三色标记位

染色指针不能支持32位平台, 不能支持压缩指针(-XX:+UseCompressedOops)

染色指针优势:
染色指针可以使得一旦某个Region的存活对象被移走, 这个Region立即就能释放和重用， 不必等待整个堆中所有指向该Region的引用都被修正才能清理。只要还有一个Region， ZGC就能完成收集。Shenandoah需要等到引用更新阶段结束以后才能释放回收集的Region。
染色指针可以大幅度减少在垃圾收集过程中内存屏障的使用数量,  设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况。ZGC截止目前并未使用任何写屏障,  只使用了读屏障(一部分是染色指针的功劳,一部分是ZGC还不支持分代收集， 没有跨代引用的问题)。减少内存屏障的使用， 对程序运行效率大有裨益。
染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关数据，， 以便日后进一步提高性能。

Linux/x86-64平台上的ZGC使用了多重映射将多个不同的虚拟内存地址映射到同一个物理内存地址上，多对一映射， ZGC在虚拟内存中看到的地址空间比实际堆内存容量更大。把染色指针中的标志位看作是地址的分段符， 那只要将这些不同的地址段都映射到同一个物理空间， 经过多重映射转换后， 就可以使用染色指针正常进行寻址了。
ZGC运作过程
- 并发标记
> (标记阶段会更新染色指针中的Marked0、Marked1)标志位
- 并发预备重分配
- 并发重分配
> ZGC执行过程中的核心阶段,这个过程要把重分配集中的存活对象复制到新的Region上, 并为重分配集中的每个Region维护一个转发表, 记录旧对象到新对象的转向关系。用户线程并发访问重分配集的对象， 读屏障会根据Region上的转发表记录将访问转发到新复制的对象,并同时修正更新该引用的值，ZGC将这种行为成为指针"自愈"能力。这样只会第一次访问旧对象时慢一次。
- 并发重映射
> 修正整个堆中指向重分配集中旧对象的所有引用。

ZGC做到了几乎整个收集过程都全程可并发，短暂停顿也只与GC Roots大小相关而与堆内存大小无关, 因而实现了任何堆上停顿都小于十毫秒的目标。

ZGC的劣势:
没有分代收集， 每次都是进行全堆回收。
假设要回收一个很大的堆耗时较长， 应用分配对象速率很快， 容易产生大量的浮动垃圾， 回收内存有可能小于回收期间产生的浮动垃圾所占空间， 堆中剩余空间越来越小。(应对方法尽可能增加堆容量大小)

ZGC支持NUMA-Aware的内存分配。(非统一内存访问架构)

#### Epsilon收集器
不能够进行垃圾收集的垃圾收集器, 堆耗尽之前就会退出, 负载小, 适合于应用只要运行数分钟甚至数秒。

### 虚拟机及垃圾收集器日志

### 内存分配与回收策略
